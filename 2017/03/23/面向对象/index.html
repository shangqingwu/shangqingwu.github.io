<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录了整个技术栈"><title>面向对象 | 董金娟的博客|学习前端</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面向对象</h1><a id="logo" href="/.">董金娟的博客|学习前端</a><p class="description">技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">面向对象</h1><div class="post-meta">Mar 23, 2017<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h4><ol>
<li>对象特征：属性，方法。</li>
<li>面向对象思想 -&gt; 也叫oo思想、oop思想；</li>
<li>面向对象的特点：<ol>
<li>封装：<code>低耦合，高内聚</code>：<ul>
<li>对同一个功能的函数，只封装一次，以后再遇到此功能，只需要调用即可，无需重写；</li>
<li>避免大量冗余代码，提高代码的重复利用率；</li>
</ul>
</li>
<li>继承：子类可以继承父类的<code>属性</code>和<code>方法</code>；</li>
<li>多态：当前方法的多种形态。后台语言中多态，包含<code>重载</code>和<code>重写</code>：<ul>
<li>重载：JS没有严格意义上的重载，有类似重载的功能。如：传不同的参数，可以实现不同的功能；</li>
<li>重写：子类可以重写父类的属性和方法；<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4></li>
</ul>
</li>
</ol>
</li>
<li><p>单例模式：把描述同一个对象的属性和方法，都放在同一个<code>命名空间</code>下；它可以避免全局变量的污染和冲突（这样不同事物之间的属性即使属性名相同，相互也不会发生冲突。）；</p>
<ul>
<li>命名空间：把描述这个对象的属性和方法，所存放的空间起了个名字，比如person1 就是命名空间</li>
<li>单例模式的本质：<code>普通对象</code>；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//在单例模式中，我们把person1或person2 也叫做“命名空间”</div><div class="line">var person1=&#123;</div><div class="line">    name:&quot;kim&quot;,</div><div class="line">    age:18,</div><div class="line">    getName:function () &#123;</div><div class="line">    alert(&quot;我的名字是&quot;+this.name);</div><div class="line">&#125;;</div><div class="line">var person2=&#123;</div><div class="line">    name:&quot;lee&quot;,</div><div class="line">    age:19,</div><div class="line">    getName:function () &#123;</div><div class="line">    alert(&quot;我的名字是&quot;+this.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>模块化开发：</strong> 对于一个大型项目，会分配给不同的工程师，进行同步开发；等所有的人都开发完成，最后进行代码合并</p>
<ul>
<li><code>单例模式</code>就是最简单的<code>模块化开发</code>；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//1.当开发一个项目时，每一个人都新建一个js文件，存储自己负责模块的js代码，同步开发</div><div class="line"></div><div class="line">//封装utils工具库，一般情况下，会单独建一个utils的js文件，里面给它封装</div><div class="line">//utils.js</div><div class="line">(function () &#123;</div><div class="line">     window.utils=&#123;// 工具库  定义一个全局变量utils，便于其他人调用里面的其他方法</div><div class="line">         getByClass:function () &#123;//通过class名来获取元素</div><div class="line">         &#125;,</div><div class="line">         jsonParse:function () &#123;//把字符串转为对象</div><div class="line">         &#125;</div><div class="line">     &#125;;</div><div class="line"> &#125;)();</div><div class="line">//header.js</div><div class="line">var header=&#123;  //头部</div><div class="line">    tab:function () &#123;</div><div class="line">        this.logo(); //本模块之间的相互调用：this.xxx</div><div class="line">    &#125;,</div><div class="line">    logo:function () &#123;&#125;,</div><div class="line">    slider:function () &#123;</div><div class="line">        main.slider(); //不同模块之间的相互调用：模块名.属性名</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//main.js</div><div class="line">var main=&#123;  //主体</div><div class="line">    tab:function () &#123;&#125;,</div><div class="line">    slider:function () &#123;&#125;//侧边栏</div><div class="line">&#125;;</div><div class="line">//footer.js</div><div class="line">var footer=&#123;  //尾部</div><div class="line">    aa:function () &#123;&#125;,</div><div class="line">    aboutMe:function () &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2.当每一个人都开发完成之后，再将所有人的代码进行合并(把他们的代码引到页面上)</div><div class="line"></div><div class="line">&lt;script src=&quot;utils.js&quot;&gt;&lt;/script&gt; //一定要先引入utils.js文件，因为后面的模块依赖于这个工具库（函数）。</div><div class="line">&lt;script src=&quot;header.js&quot;&gt;&lt;/script&gt;  //剩余其他的文件引入顺序没有特定要求。</div><div class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;footer.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单例模式的优缺点：</p>
<ul>
<li>优点：<ol>
<li>单例模式可以避免全局变量的污染和冲突；</li>
<li>单例模式是最简单的模块化开发；<ul>
<li><code>本模块</code>之间的相互调用：<code>this.属性名</code></li>
<li><code>不同模块</code>之间的相互调用：<code>模块名.属性名</code></li>
</ul>
</li>
</ol>
</li>
<li>缺点：当多个对象功能一样时，会存在大量冗余代码；<ul>
<li><code>解决措施：工厂模式</code>；<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4></li>
</ul>
</li>
</ul>
</li>
<li>工厂模式的<code>本质</code>：<code>封装</code>；<ul>
<li>封装三步骤：<ol>
<li>引进原材料<ul>
<li>创建一个空对象{}  new Object();</li>
</ul>
</li>
<li>加工<ul>
<li>给对象添加属性和方法；</li>
</ul>
</li>
<li>输出产品<ul>
<li>输出已经加工后的对象；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function person(name,age) &#123;//封装三步骤</div><div class="line">    //1.创建一个空对象</div><div class="line">    var obj=new Object();  //var obj=&#123;&#125;;方式  也可以</div><div class="line">    //2.添加属性和方法</div><div class="line">    obj.name=name;</div><div class="line">    obj.age=age;</div><div class="line">    obj.getName=function () &#123;</div><div class="line">        alert(&quot;我的名字是&quot;+this.name);//this指的是obj</div><div class="line">    &#125;;</div><div class="line">    //3.输出对象</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">var person1=person(&quot;kim&quot;,18);  //person1接收的是返回的obj</div><div class="line">var person2=person(&quot;lee&quot;,19);   //person2接收的是返回的obj   但这两个的返回值不相同，因为传的实参不同</div><div class="line">person1.getName();  //我的名字是&quot;kim&quot;</div><div class="line">person2.getName();  //我的名字是&quot;lee&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><ol>
<li><p>如果想让工厂模式的调用方式，跟系统类的调用方式一样，–&gt; <code>自定义类</code>需要做两步：</p>
<ul>
<li><code>首字母大写</code>（不成文的规定，小写也可以实现，但是最好大写）；</li>
<li><code>添加一个new</code>；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;  //首字母大写-&gt;构造函数</div><div class="line">    //封装三步骤</div><div class="line">    //1.系统会自动创建一个对象：this</div><div class="line">    //2.添加属性和方法</div><div class="line">    this.name=name;  //构造函数中的this是实例person1，因为构造函数中默认返回的this被外面的实例接收了</div><div class="line">    this.age=age;</div><div class="line">    this.getName=function () &#123;</div><div class="line">        alert(&quot;我的名字是&quot;+this.name);</div><div class="line">    &#125;;</div><div class="line">    //3.系统默认帮我们返回一个对象this  -&gt; return this;   </div><div class="line">&#125;</div><div class="line">var person1=new Person(&quot;kim&quot;,18);  //添加一个new</div><div class="line">person1.getName();  //我的名字是&quot;kim&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数模式 跟 工厂模式 的区别：</p>
<ol>
<li>调用的时候：<ul>
<li><strong>工厂模式</strong>：<code>普通函数的调用</code>；  //person();</li>
<li><strong>构造函数模式</strong>：<code>new+首字母大写(参数)</code>；  //new Person();</li>
</ul>
</li>
<li>函数体内的不同：<ul>
<li><strong>工厂模式</strong>：三步；<ul>
<li>1.创建对象（<code>创建一个空对象</code>）；</li>
<li>2.加工对象（<code>给对象添加属性和方法</code>）；</li>
<li>3.返回对象（<code>输出已经加工后的对象</code>）；</li>
</ul>
</li>
<li><strong>构造函数模式</strong>：一步；（系统会默认帮我们完成第一步和第三步）<ul>
<li>1.加工对象（<code>给对象添加属性和方法</code>）；</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>this总结：<ol>
<li>元素身上的事件被触发的时候，会执行一个函数，函数中的this，指向当前这个元素；</li>
<li>自执行函数中的this永远都是window；</li>
<li>函数被调用时，看函数前面是否有点，有点，点前面是谁this就是谁；没有点，this就是window。</li>
<li>构造函数中的this是实例；（因为构造函数中默认返回的this被外面的实例接收了）</li>
</ol>
</li>
<li>学习构造函数的目的：<ul>
<li>了解系统类的构成；</li>
<li>自己定义一个类，并且创建实例；</li>
</ul>
</li>
<li>关于构造函数的小细节：<ol>
<li>构造函数中的this都是<code>实例</code>；</li>
<li>构造函数中存放的都是<code>私有</code>的<code>属性</code>和<code>方法</code>；（不能共同使用）<ul>
<li>公有的放在<code>类.prototype.属性或方法</code>上</li>
</ul>
</li>
<li><code>实例</code>只跟构造函数中的<code>this.xxx</code>有关，跟var没有任何关系；</li>
<li>构造函数中，系统默认为我们创建一个实例，并且默认返回一个实例；<ul>
<li>不建议自己手动返回对象，如果非要手动返回的话：<ol>
<li>返回的是<code>基本数据类型</code>，<code>无效</code>；实例该有的属性和方法仍然有，依然返回实例的属性和方法。</li>
<li>返回的是<code>引用数据类型</code>，以前给实例上添加的属性和方法都无效了；会<code>覆盖</code>实例的属性和方法。</li>
</ol>
</li>
</ul>
</li>
<li>构造函数：<code>实例</code> 和 <code>类</code> 打交道。<ul>
<li><code>new后面是类</code>；</li>
<li><code>new出来的是实例</code>；</li>
</ul>
</li>
<li>在new一个实例的时候，如果不需要传参，()可以省略；</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ary=new Array();</div><div class="line">console.log(ary);  //[]</div><div class="line">var ary1=new Array;</div><div class="line">console.log(ary1);  //[]</div></pre></td></tr></table></figure>
<ol>
<li><p>缺点：构造函数中存放的都是<code>私有</code>的<code>属性和方法</code>；（不能共同使用）</p>
<ul>
<li><code>解决措施：构造函数原型模式</code>；<ul>
<li>在构造函数原型模式中，把公有的属性和方法放在<code>类.prototype.属性或方法</code>上    <h4 id="构造函数原型模式"><a href="#构造函数原型模式" class="headerlink" title="构造函数原型模式"></a>构造函数原型模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;  //首字母大写-&gt;构造函数</div><div class="line">    //封装三步骤</div><div class="line">    //1.系统会自动创建一个对象：this</div><div class="line">    //2.添加属性和方法</div><div class="line">    this.name=name; //构造函数中的this是实例；</div><div class="line">    this.age=age;</div><div class="line">    //3.系统默认帮我们返回一个对象this </div><div class="line">&#125;</div><div class="line">Person.prototype.getName=function () &#123;  //（系统自带的）prototype上：存的都是公有的属性和方法</div><div class="line">    alert(&quot;我的名字是&quot;+this.name);</div><div class="line">&#125;;</div><div class="line">var person1=new Person(&quot;kim&quot;,18);</div><div class="line">var person2=new Person(&quot;lee&quot;,19);</div><div class="line">person1.getName();//我的名字是&quot;kim&quot;</div><div class="line">person2.getName();//我的名字是&quot;lee&quot;</div><div class="line">console.log(person1.getName===person2.getName);//true  说明getName是公有的，开辟了一个空间地址，person1和person2都可以调用。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原型模式的基础知识：</p>
<ol>
<li>每个<strong>函数数据类型（普通函数、构造函数）</strong> 上，都有一个属性，叫做<code>prototype</code>，prototype是个<code>对象</code>，也是一个<code>原型</code>；</li>
<li><strong>prototype这个对象上</strong>，存放的都是<code>公有</code>的属性和方法，它<code>天生自带的一个属性constructor</code>，指向当前这个构造函数（<code>当前所属的类</code>）；</li>
<li>每个<strong>对象数据类型（普通对象、实例、prototype）</strong> 上，都有一个属性叫做<code>__proto__</code>，指向<code>当前实例所属类的原型</code>；</li>
</ol>
</li>
</ol>
<ul>
<li>图示：<br><img src="http://i1.piimg.com/4851/51aa32dd0201eeba.png" alt="构造函数原型模式"></li>
</ul>
<ol>
<li>Object.prototype上的方法：<ul>
<li>hasOwnProperty():判断是否为对象的私有属性；</li>
<li>obj1.isPrototypeOf(obj2):obj1是否在obj2的原型链上；</li>
<li>propertyIsEnumerable:是否为可枚举的属性；</li>
</ul>
</li>
<li><code>__proto__原型链</code>：<ul>
<li>如果想查找：对象.属性名<ul>
<li>先看该对象的<code>私有空间</code>中是否有该属性名，如果<code>有</code>，说明这个属性是<code>私有属性</code>；</li>
<li>如果没有，通过<code>__proto__往当前实例所属类的原型</code>上找，<code>找到了</code>，说明这个属性是<code>公有属性</code>；</li>
<li>如果还<code>没找到</code>，继续通过<code>__proto__</code>一直往上找，<code>直到找到基类Object.prototype原型上</code>，还<code>没有找到</code>的话，返回<code>undefined</code>（属性不会报错）；</li>
</ul>
</li>
</ul>
</li>
<li>原型模式：实例、类、原型（prototype） 三者打交道；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fn() &#123; //构造函数存放的都是私有的属性和方法</div><div class="line">    this.x=100;</div><div class="line">    this.y=200;</div><div class="line">&#125;</div><div class="line">//prototype原型上，存放的都是公有的属性和方法</div><div class="line">Fn.prototype.getX=function () &#123;</div><div class="line">    alert(this.x);</div><div class="line">&#125;;</div><div class="line">var f1=new Fn(); //实例</div><div class="line">//f1.getX();  //实例可以调用私有的属性和方法，也可以调用公有的属性和方法</div><div class="line">alert(f1.getX===Fn.prototype.getX);//true</div><div class="line">alert(f1.__proto__.getX===Fn.prototype.getX);//true -&gt; IE10及10以下禁止使用__proto__来查找属性名 -&gt; 报错：无法获取未定义或 null 引用的属性“getX”</div></pre></td></tr></table></figure>
</li>
</ol>
</div><div class="tags"><a href="/tags/面向对象/">面向对象</a></div><div class="post-nav"><a href="/2017/03/23/2-1-1-call-apply-bind/" class="pre">call/apply/bind</a><a href="/2017/01/20/git的应用/" class="next">git的应用</a></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git的应用/">git的应用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/搭建博客/">搭建博客</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/预解释/" style="font-size: 15px;">预解释</a> <a href="/tags/函数/" style="font-size: 15px;">函数</a> <a href="/tags/内存和内存释放/" style="font-size: 15px;">内存和内存释放</a> <a href="/tags/this/" style="font-size: 15px;">this</a> <a href="/tags/面向对象/" style="font-size: 15px;">面向对象</a> <a href="/tags/修改this/" style="font-size: 15px;">修改this</a> <a href="/tags/数组中最小值和最大值/" style="font-size: 15px;">数组中最小值和最大值</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/2-2-1-类数组转数组/">2.2.1 类数组转数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/null和undefined的区别/">null和undefined的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/2-2-3-JSON及操作/">2.2.3 JSON及操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/2-2-2-DOM及操作/">2.2.2 DOM及操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/2-1-2-求数组中最小值和最大值/">2.1.2 求数组中最小值和最大值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/2-1-1-call-apply-bind/">call/apply/bind</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/面向对象/">面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/20/git的应用/">git的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/19/预解释、函数、内存、this/">预解释、函数、内存、this</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/19/用hexo搭建一个博客/">用hexo搭建博客</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:null" target="_blank" class="fa fa-email"> </a><a href="null" target="_blank" class="fa fa-weibo"></a><a href="null" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">董金娟</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script></body></html>